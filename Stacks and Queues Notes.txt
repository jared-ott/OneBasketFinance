Stacks and Queues
	Collection ADTs are unstructured if they just hold stuff
	Sorting imposed structure (ordered != sorted) as part of the collection's state
	Other ADTs: structure is a part of the behavior
	Difference is subtle, but vital
	We now look at restricted access data structures
	
Stack
	Definition
		Data structure that stores elements in a LIFO (Last-in, First-out) manner
		Only two core pieces of functionality
			Push: places an element at the top
			Pop: Removes and possibly returns the element at the top
			
	Variations
		Secondary functionality
			Way to determine size (isEmpty/isFull)
			Arbitrary access method (index-based find)
			Peek: retrieve, but do not remove, the element at the top
			A way to iterate over all the elements in the stack
			A way to "clear" the stack
			Other considerations:
				Popping an empty stack
					Return a flag  (null)
					throw an exception
					noop -> no return variable, no operation
					
	Applications
		Program Stacks
		In general: keeping track of breadcrumbs
		Unfolding recursion
		Compiler: evaluation of expressions
		
	Look up notes: Deque and stuff
	
Trees
	Tree - Connected acyclic graph
		For our purposes, a collection of nodes
		Node - Keys/values are stored in them
		Edges - connect nodes
		Our trees will be oriented (top to bottom)
			Ancestor/Descendant relationship
			Parent/Child relationship
			
	Structure
		Top Node: root (no parent)
		Bottom Nodes: leaves (no children)
		Tree Type: Binary tree (max 2 children)
			Results in left/right child
		Unique path between two nodes
		Length of path: Number of edges between two nodes
		Depth of node: The length of the unique path from the root to that node
		Depth of tree: Largest depth of any node
		Full: A tree is full if every node is present up to its depth
		
	Balanced Binary Search Trees are bestest
	
	Pseudo Code for Tree implementation
		
		TreeNode<T>
			//State
			T item
			TreeNode<T> leftChild
			TreeNode<T> rightChild
			TreeNode<T> parent
			
			//Behavior
			
		BinaryTree<T>
			//State
			TreeNode<T> root
			int size
			int depth?
			
			//Behavior
			Pre-Order Traversal (node u) [Recursive]
				Input : a node, u
				Output : a pre-order traversal of tree rooted at u
				
				if(u = null)
					return
				Process u
				Pre-Order Traversal(u -> leftChild)
				Pre-Order Traversal(u -> rightChild)
				
			In-Order Traversal (node u) [Recursive]
				Input : a node, u
				Output : an in-order traversal of tree rooted at u
				
				if(u = null)
					return
				In-Order Traversal(u -> leftChild)
				Process u
				In-Order Traversal(u -> rightChild)
				
			Post-Order Traversal (node u) [Recursive]
				Input : a node, u
				Output : a post-order traversal of tree rooted at u
				
				if(u = null)
					return
				Post-Order Traversal(u -> leftChild)
				Post-Order Traversal(u -> rightChild)
				Process u
				
			Pre-Order Traversal (BinaryTree T) [Non-Recursive]
				Input: a binary tree T
				Output: a pre-order traversal of T
				
				S <- empty stack
				S.push(T->root)
				while(S is not empty)
					x <- S.pop()
					S.push(x -> rightChild)
					S.push(x -> leftChild)
					process x
					
			Breadth First Search
				->Top to bottom, left to right (like a book)
				Input: A BinaryTree T
				Output: A BFS traversal of T
				
				Q <- Empty queue
				Q.enq(T -> root)
				while(Q is not empty)
					x <- Q.deq()
					Q.enq(x -> leftChild)
					Q.enq(x -> rightChild)
					process x
				Q.enq(root)
				
		Heap: A Binary Search Tree that is
			1. Full: All nodes present except last row
			2. All nodes full to the left in last row
			3. For each node, it's key value is greater than both of it's children (max heap)
			
			Heap Insert
				Insert at lowest level, as most left as possible
				Iteratively swap with its parent if it is greater than the parent	
					Stop when it is less than parent, or is the root
					
			Heap Remove
				Insert lowest-right most element to where the remove was
				Swap with children until it satisfies #3
			
		HeapSort
			Input: A Collection "A"
			Output: "A" Sorted
			
			H <- maxHeap
			
			foreach (a in A)
				H.insert(a)
				
			for (i = n ... 1)
				a_1 <- H.getMax
				
			output A
		